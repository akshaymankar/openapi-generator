{-
   OpenAPI Petstore

   This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\

   OpenAPI Version: 3.0.1
   OpenAPI Petstore API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OpenAPIPetstore.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OpenAPIPetstore.Model where

import OpenAPIPetstore.Core
import OpenAPIPetstore.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import OpenAPIPetstore.Model.ModelByteArray
import OpenAPIPetstore.Model.ModelDate
import OpenAPIPetstore.Model.ModelDateTime

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** FormatTest
-- | FormatTest
data FormatTest = FormatTest
  { formatTestInteger :: !(Maybe Int) -- ^ "integer"
  , formatTestInt32 :: !(Maybe Int) -- ^ "int32"
  , formatTestInt64 :: !(Maybe Integer) -- ^ "int64"
  , formatTestNumber :: !(Double) -- ^ /Required/ "number"
  , formatTestFloat :: !(Maybe Float) -- ^ "float"
  , formatTestDouble :: !(Maybe Double) -- ^ "double"
  , formatTestString :: !(Maybe Text) -- ^ "string"
  , formatTestByte :: !(ByteArray) -- ^ /Required/ "byte"
  , formatTestBinary :: !(Maybe FilePath) -- ^ "binary"
  , formatTestDate :: !(Date) -- ^ /Required/ "date"
  , formatTestDateTime :: !(Maybe DateTime) -- ^ "dateTime"
  , formatTestUuid :: !(Maybe Text) -- ^ "uuid"
  , formatTestPassword :: !(Text) -- ^ /Required/ "password"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FormatTest
instance A.FromJSON FormatTest where
  parseJSON = A.withObject "FormatTest" $ \o ->
    FormatTest
      <$> (o .:? "integer")
      <*> (o .:? "int32")
      <*> (o .:? "int64")
      <*> (o .:  "number")
      <*> (o .:? "float")
      <*> (o .:? "double")
      <*> (o .:? "string")
      <*> (o .:  "byte")
      <*> (o .:? "binary")
      <*> (o .:  "date")
      <*> (o .:? "dateTime")
      <*> (o .:? "uuid")
      <*> (o .:  "password")

-- | ToJSON FormatTest
instance A.ToJSON FormatTest where
  toJSON FormatTest {..} =
   _omitNulls
      [ "integer" .= formatTestInteger
      , "int32" .= formatTestInt32
      , "int64" .= formatTestInt64
      , "number" .= formatTestNumber
      , "float" .= formatTestFloat
      , "double" .= formatTestDouble
      , "string" .= formatTestString
      , "byte" .= formatTestByte
      , "binary" .= formatTestBinary
      , "date" .= formatTestDate
      , "dateTime" .= formatTestDateTime
      , "uuid" .= formatTestUuid
      , "password" .= formatTestPassword
      ]


-- | Construct a value of type 'FormatTest' (by applying it's required fields, if any)
mkFormatTest
  :: Double -- ^ 'formatTestNumber' 
  -> ByteArray -- ^ 'formatTestByte' 
  -> Date -- ^ 'formatTestDate' 
  -> Text -- ^ 'formatTestPassword' 
  -> FormatTest
mkFormatTest formatTestNumber formatTestByte formatTestDate formatTestPassword =
  FormatTest
  { formatTestInteger = Nothing
  , formatTestInt32 = Nothing
  , formatTestInt64 = Nothing
  , formatTestNumber
  , formatTestFloat = Nothing
  , formatTestDouble = Nothing
  , formatTestString = Nothing
  , formatTestByte
  , formatTestBinary = Nothing
  , formatTestDate
  , formatTestDateTime = Nothing
  , formatTestUuid = Nothing
  , formatTestPassword
  }


-- * Enums



