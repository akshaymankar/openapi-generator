{-
   OpenAPI Petstore

   This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\

   OpenAPI Version: 3.0.1
   OpenAPI Petstore API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OpenAPIPetstore.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OpenAPIPetstore.Model where

import OpenAPIPetstore.Core
import OpenAPIPetstore.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import OpenAPIPetstore.Model.Array

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** TypeHolderExample
-- | TypeHolderExample
data TypeHolderExample = TypeHolderExample
  { typeHolderExampleStringItem :: !(Text) -- ^ /Required/ "string_item"
  , typeHolderExampleNumberItem :: !(Double) -- ^ /Required/ "number_item"
  , typeHolderExampleIntegerItem :: !(Int) -- ^ /Required/ "integer_item"
  , typeHolderExampleBoolItem :: !(Bool) -- ^ /Required/ "bool_item"
  , typeHolderExampleArrayItem :: !([Int]) -- ^ /Required/ "array_item"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TypeHolderExample
instance A.FromJSON TypeHolderExample where
  parseJSON = A.withObject "TypeHolderExample" $ \o ->
    TypeHolderExample
      <$> (o .:  "string_item")
      <*> (o .:  "number_item")
      <*> (o .:  "integer_item")
      <*> (o .:  "bool_item")
      <*> (o .:  "array_item")

-- | ToJSON TypeHolderExample
instance A.ToJSON TypeHolderExample where
  toJSON TypeHolderExample {..} =
   _omitNulls
      [ "string_item" .= typeHolderExampleStringItem
      , "number_item" .= typeHolderExampleNumberItem
      , "integer_item" .= typeHolderExampleIntegerItem
      , "bool_item" .= typeHolderExampleBoolItem
      , "array_item" .= typeHolderExampleArrayItem
      ]


-- | Construct a value of type 'TypeHolderExample' (by applying it's required fields, if any)
mkTypeHolderExample
  :: Text -- ^ 'typeHolderExampleStringItem' 
  -> Double -- ^ 'typeHolderExampleNumberItem' 
  -> Int -- ^ 'typeHolderExampleIntegerItem' 
  -> Bool -- ^ 'typeHolderExampleBoolItem' 
  -> [Int] -- ^ 'typeHolderExampleArrayItem' 
  -> TypeHolderExample
mkTypeHolderExample typeHolderExampleStringItem typeHolderExampleNumberItem typeHolderExampleIntegerItem typeHolderExampleBoolItem typeHolderExampleArrayItem =
  TypeHolderExample
  { typeHolderExampleStringItem
  , typeHolderExampleNumberItem
  , typeHolderExampleIntegerItem
  , typeHolderExampleBoolItem
  , typeHolderExampleArrayItem
  }


-- * Enums



