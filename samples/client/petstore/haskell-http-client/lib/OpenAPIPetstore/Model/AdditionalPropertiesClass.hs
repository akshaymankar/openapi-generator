{-
   OpenAPI Petstore

   This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\

   OpenAPI Version: 3.0.1
   OpenAPI Petstore API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OpenAPIPetstore.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OpenAPIPetstore.Model where

import OpenAPIPetstore.Core
import OpenAPIPetstore.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import OpenAPIPetstore.Model.A
import OpenAPIPetstore.Model.Array
import OpenAPIPetstore.Model.Map

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** AdditionalPropertiesClass
-- | AdditionalPropertiesClass
data AdditionalPropertiesClass = AdditionalPropertiesClass
  { additionalPropertiesClassMapString :: !(Maybe (Map.Map String Text)) -- ^ "map_string"
  , additionalPropertiesClassMapNumber :: !(Maybe (Map.Map String Double)) -- ^ "map_number"
  , additionalPropertiesClassMapInteger :: !(Maybe (Map.Map String Int)) -- ^ "map_integer"
  , additionalPropertiesClassMapBoolean :: !(Maybe (Map.Map String Bool)) -- ^ "map_boolean"
  , additionalPropertiesClassMapArrayInteger :: !(Maybe (Map.Map String [Int])) -- ^ "map_array_integer"
  , additionalPropertiesClassMapArrayAnytype :: !(Maybe (Map.Map String [A.Value])) -- ^ "map_array_anytype"
  , additionalPropertiesClassMapMapString :: !(Maybe (Map.Map String (Map.Map String Text))) -- ^ "map_map_string"
  , additionalPropertiesClassMapMapAnytype :: !(Maybe (Map.Map String (Map.Map String A.Value))) -- ^ "map_map_anytype"
  , additionalPropertiesClassAnytype1 :: !(Maybe A.Value) -- ^ "anytype_1"
  , additionalPropertiesClassAnytype2 :: !(Maybe A.Value) -- ^ "anytype_2"
  , additionalPropertiesClassAnytype3 :: !(Maybe A.Value) -- ^ "anytype_3"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdditionalPropertiesClass
instance A.FromJSON AdditionalPropertiesClass where
  parseJSON = A.withObject "AdditionalPropertiesClass" $ \o ->
    AdditionalPropertiesClass
      <$> (o .:? "map_string")
      <*> (o .:? "map_number")
      <*> (o .:? "map_integer")
      <*> (o .:? "map_boolean")
      <*> (o .:? "map_array_integer")
      <*> (o .:? "map_array_anytype")
      <*> (o .:? "map_map_string")
      <*> (o .:? "map_map_anytype")
      <*> (o .:? "anytype_1")
      <*> (o .:? "anytype_2")
      <*> (o .:? "anytype_3")

-- | ToJSON AdditionalPropertiesClass
instance A.ToJSON AdditionalPropertiesClass where
  toJSON AdditionalPropertiesClass {..} =
   _omitNulls
      [ "map_string" .= additionalPropertiesClassMapString
      , "map_number" .= additionalPropertiesClassMapNumber
      , "map_integer" .= additionalPropertiesClassMapInteger
      , "map_boolean" .= additionalPropertiesClassMapBoolean
      , "map_array_integer" .= additionalPropertiesClassMapArrayInteger
      , "map_array_anytype" .= additionalPropertiesClassMapArrayAnytype
      , "map_map_string" .= additionalPropertiesClassMapMapString
      , "map_map_anytype" .= additionalPropertiesClassMapMapAnytype
      , "anytype_1" .= additionalPropertiesClassAnytype1
      , "anytype_2" .= additionalPropertiesClassAnytype2
      , "anytype_3" .= additionalPropertiesClassAnytype3
      ]


-- | Construct a value of type 'AdditionalPropertiesClass' (by applying it's required fields, if any)
mkAdditionalPropertiesClass
  :: AdditionalPropertiesClass
mkAdditionalPropertiesClass =
  AdditionalPropertiesClass
  { additionalPropertiesClassMapString = Nothing
  , additionalPropertiesClassMapNumber = Nothing
  , additionalPropertiesClassMapInteger = Nothing
  , additionalPropertiesClassMapBoolean = Nothing
  , additionalPropertiesClassMapArrayInteger = Nothing
  , additionalPropertiesClassMapArrayAnytype = Nothing
  , additionalPropertiesClassMapMapString = Nothing
  , additionalPropertiesClassMapMapAnytype = Nothing
  , additionalPropertiesClassAnytype1 = Nothing
  , additionalPropertiesClassAnytype2 = Nothing
  , additionalPropertiesClassAnytype3 = Nothing
  }


-- * Enums



